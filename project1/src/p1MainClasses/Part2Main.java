package p1MainClasses;

import java.io.FileNotFoundException;
import java.util.AbstractMap;
import java.util.Scanner;

import dataGenerator.DataGenerator;
import dataGenerator.DataReader;
import interfaces.MySet;
import mySetImplementations.P1_P2;
import mySetImplementations.P3;
import mySetImplementations.P4;
import timeCollection.StrategiesTimeCollection;

public class Part2Main {

	public static void main(String[] args) throws FileNotFoundException {
		
		int finalSize = 50000;
		int incrementalSizeStep = 200;
		int initialSize = 1000;
		int m = 50;
		int n = 10;
	    int repetitionsPerSize = 200;
		MySet[]t = null;
		P1_P2<Integer> s1 = new P1_P2<Integer>("1");
		P1_P2<Integer> s2 = new P1_P2<Integer>("2");
		P3<Integer> s3 = new P3<Integer>("3");
		P4 <Integer> s4 = new P4 <Integer>("4");
		StrategiesTimeCollection<Integer> [] resultsPerStrategy = null;
		Scanner scan = new Scanner(System.in);
		System.out.print("Enter n: ");
		n = scan.nextInt();
		System.out.print("Enter m: ");
		m = scan.nextInt();
		System.out.print("Enter initialSize: ");
		initialSize = scan.nextInt();
		System.out.print("Enter finalSize: ");
		finalSize = scan.nextInt();
		System.out.print("Enter iincrementalSizeStep: ");
		incrementalSizeStep = scan.nextInt();
		System.out.print("Enter repetitionsPerSize : ");
		repetitionsPerSize = scan.nextInt();
			
			for (int size=initialSize; size<=finalSize; size+=incrementalSizeStep) { 
   
	// For each strategy, reset the corresponding internal variable that will be used to store the sum 
    // of times that the particular strategy exhibits for the current size size.
    for (StrategiesTimeCollection<Integer> strategy : resultsPerStrategy) 
        strategy.resetSum();    // set to 0 an internal instance variable used to accumulate sum of times
			
	// Run all trials for the current size. 
    for (int r = 0; r<repetitionsPerSize; r++) {
    	
		// The following will be the common dataset to be used in the current trial by all the strategies being
        // tested. Here, that data set is generated by a method that gets as input (parameter values): n, m, size. 
        // Where n and m are the number of companies and number of crime events, respective. The generated
        // must satisfy: size  =  i=1nj=1m(dataset[i][j].length)
    	DataGenerator dg = new DataGenerator(n,m, size);
        Integer[][][] dataset = (Integer[][][]) dg.generateData();  // data set for this trial of given size

        // Apply each one of the strategies being tested using the previous dataset (of size size) as input; 
        // and, for each, estimate the time that the execution takes.
        for (StrategiesTimeCollection<Integer> strategy : resultsPerStrategy) {	
            long startTime = System.nanoTime();  // Measure system’s clock time before.
            strategy.runTrial(dataset);          // Run the strategy using the data in dataset.        
            long endTime = System.nanoTime();    // Measure system’s clock time after.

                           int estimatedTime = (int) (endTime-startTime);   // The estimated time.
            // Accumulate the estimated time (add it) to sum of times that the current strategy has 
            // so far accumulated  on the previous trials for datasets of the current size. 
            strategy.incSum(estimatedTime);    				
        }
        

		for(int j = 0; j < m; j++) {
			t[j] = null;
			for(int i = 0; i < n; i++) {
				for(int k = 0; k < dataset[i][j].length; k++)
					t[j].add(dataset[i][j][k]);
			}
		}
    }
    // For each strategy, compute the average time for the current size.	
    for (StrategiesTimeCollection<Integer> strategy : resultsPerStrategy)
        strategy.add( new AbstractMap.SimpleEntry<Integer, Float>
                          (size, (strategy.getSum()/((float) repetitionsPerSize)))
                    ); 
    

}

	}
	public String Allresults(String res) {
		return res;
	}
	
}
