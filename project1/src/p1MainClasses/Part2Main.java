package p1MainClasses;

import java.io.FileNotFoundException;
import java.util.AbstractMap;

import dataGenerator.DataGenerator;
import dataGenerator.DataReader;
import mySetImplementations.P1_P2;
import mySetImplementations.P3;
import mySetImplementations.P4;
import timeCollection.StrategiesTimeCollection;

public class Part2Main {

	public static void main(String[] args) throws FileNotFoundException {
		
		
		FilesGeneratorMain fg = new FilesGeneratorMain();
		P1_P2<Integer> s1 = new P1_P2<Integer>("1");
		P1_P2<Integer> s2 = new P1_P2<Integer>("2");
		P3<Integer> s3 = new P3<Integer>("3");
		P4 <Integer> s4 = new P4 <Integer>("4");
		DataReader dr = new DataReader();
		StrategiesTimeCollection<Integer> [] resultsPerStrategy = null;

			int finalSize = 0;
			int incrementalSizeStep = 0;
			int initialSize = 0;
			int m = 0;
			int n = 0;
			for (int size=initialSize; size<=finalSize; size+=incrementalSizeStep) { 
   
	// For each strategy, reset the corresponding internal variable that will be used to store the sum 
    // of times that the particular strategy exhibits for the current size size.
    for (StrategiesTimeCollection<Integer> strategy : resultsPerStrategy) 
        strategy.resetSum();    // set to 0 an internal instance variable used to accumulate sum of times
			
    int repetitionsPerSize = 0;
	// Run all trials for the current size. 
    for (int r = 0; r<repetitionsPerSize; r++) {
    	
		// The following will be the common dataset to be used in the current trial by all the strategies being
        // tested. Here, that data set is generated by a method that gets as input (parameter values): n, m, size. 
        // Where n and m are the number of companies and number of crime events, respective. The generated
        // must satisfy: size  =  i=1nj=1m(dataset[i][j].length)
    	DataGenerator dg = new DataGenerator(n,m, size);
        Integer[][][] dataset = (Integer[][][]) dg.generateData();  // data set for this trial of given size

        // Apply each one of the strategies being tested using the previous dataset (of size size) as input; 
        // and, for each, estimate the time that the execution takes.
        for (StrategiesTimeCollection<Integer> strategy : resultsPerStrategy) {	
            long startTime = System.nanoTime();  // Measure system’s clock time before.
            strategy.runTrial(dataset);          // Run the strategy using the data in dataset.        
            long endTime = System.nanoTime();    // Measure system’s clock time after.

                           int estimatedTime = (int) (endTime-startTime);   // The estimated time.
            // Accumulate the estimated time (add it) to sum of times that the current strategy has 
            // so far accumulated  on the previous trials for datasets of the current size. 
            strategy.incSum(estimatedTime);    				
        }
        

//		for(int j = 0; j < m; j++) {
//			t[j] = null;
//			for(int i = 0; i < n; i++) {
//				for(int k = 0; k < dataset[i][j].length; k++)
//					t[j].add(dataset[i][j][k]);
//			}
//		}
    }
    // For each strategy, compute the average time for the current size.	
    for (StrategiesTimeCollection<Integer> strategy : resultsPerStrategy)
        strategy.add( new AbstractMap.SimpleEntry<Integer, Float>
                          (size, (strategy.getSum()/((float) repetitionsPerSize)))
                    ); 
    

}

	}
	public String Allresults(String res) {
		return res;
	}
	
}
